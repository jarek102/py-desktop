# DEVELOPMENT.md

## 1. Tech Stack & Constraints

### Core Technologies

* **Language:** Python 3.14+
* **Desktop Shell Library:** [Astal](https://github.com/Aylur/astal) (via GObject Introspection)
* **UI Toolkit:** GTK 4.0 + LibAdwaita 1.0
* **UI Definition:** Blueprint (`.blp`) files use BLUEPRINT.md to work with .blp files.
* **Styling:** SCSS (`.scss`) -> compiled to CSS

### üîç Strict Constraints for AI

**You must adhere to these rules when generating code:**

1. **Astal Over GTK:**
* Always prefer `astal` namespace widgets over `Gtk` namespace when available (e.g., use `Astal.Window` instead of `Gtk.Window` for the main shell).
* Astal windows provide essential desktop shell features (anchors, exclusivity, layers) that standard GTK windows lack.


2. **Blueprint for UI:**
* **NEVER** build widget trees inside Python code (e.g., `box.append(child)`).
* **ALWAYS** define the UI structure in a `.blp` file.
* **ALWAYS** create a matching Python class with the `@Gtk.Template` decorator.


3. **Type Safety & Hallucinations:**
* The project contains a `typings/` folder generated by `astalgen.sh`. **Assume these type hints are the absolute truth.**
* Do not invent methods that exist in standard GTK4 if they are missing from the `typings/` definitions.
* *Note:* Astal objects are GObjects. They use `get_property("name")` and `set_property("name", val)` under the hood, but Python properties (e.g., `widget.visible = True`) are preferred.


4. **Reactive Patterns (The "Binding" Strategy):**
* **In Blueprint:** Use the native bind syntax: `label: bind template.my_prop;`
* **In Python:** Use `GObject.bind_property` for syncing two objects.
* **Do NOT** manually connect to `notify::property` signals for simple value updates.
* **Do NOT** try to use the TypeScript `bind()` syntax in Python code. It does not exist.

5. **Services:**
* Astal services (Battery, Mpris, Network, etc.) are singletons.
* Access them via `get_default()`.
* *Example:* `battery = AstalBattery.get_default()`



---

## 2. Project Structure

```text
src/
‚îú‚îÄ‚îÄ main.py              # Entry point
‚îú‚îÄ‚îÄ App.py               # Application logic
‚îú‚îÄ‚îÄ ui/                  # Widget components
‚îÇ   ‚îú‚îÄ‚îÄ Bar.py           # Python logic
‚îÇ   ‚îú‚îÄ‚îÄ Bar.blp          # UI definition
‚îÇ   ‚îî‚îÄ‚îÄ style.scss       # Global styles
‚îú‚îÄ‚îÄ services/            # Custom services (non-Astal)
‚îî‚îÄ‚îÄ utils/               # Helper functions
typings/                 # GObject Introspection stubs (AUTO-GENERATED)

```

---

## 3. Coding Patterns Cheatsheet

### A. Creating a Widget (Python + Blueprint)

**`src/ui/MyWidget.blp`**

```blueprint
using Gtk 4.0;
using Astal 3.0;

template $MyWidget : Astal.Box {
  css-classes: ["my-widget"];

  Label label_id {
    // Declarative binding to a GObject property defined in Python
    label: bind template.custom_text;
  }
}

```

**`src/ui/MyWidget.py`**

```python
import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Astal", "3.0")
from gi.repository import Gtk, GObject, Astal

@Gtk.Template(resource_path="/com/github/user/project/ui/MyWidget.blp")
class MyWidget(Astal.Box):
    __gtype_name__ = "MyWidget"

    # Define the GObject property for Blueprint to bind to
    custom_text = GObject.Property(type=str, default="Init")

    def __init__(self):
        super().__init__()
        # Logic here

```

### B. Using Astal Services

```python
from gi.repository import AstalBattery

class BatteryLabel(Astal.Label):
    def __init__(self):
        super().__init__()
        self._battery = AstalBattery.get_default()

        # Bind the battery percentage to this label's label property
        self._battery.bind_property(
            "percentage", 
            self, 
            "label", 
            GObject.BindingFlags.SYNC_CREATE
        )

```

## 4. Styling & UI Architecture

### A. The SCSS Layer

We use a hybrid approach to keep styles manageable:

1. **`style.scss` (Global):**
* **Design Tokens:** Variables for colors, transitions, and spacing.
* **LibAdwaita Integration:** Always prefer referencing `@accent_color`, `@window_bg_color`, etc., to support system-wide dark/light mode.
* **Utilities:** Generic classes like `.mt-10` or `.flex-center`.


2. **Component SCSS:**
* Styles specific to a widget (e.g., `.bar-clock`) are stored near the component or imported into the main sheet.



### B. Blueprint (`.blp`) Patterns

Blueprint is the primary way to define UI.

* **Template Syntax:** Use the `template $ClassName : SuperClass` format.
* **Declarative Bindings:** Use the `bind` keyword to link UI properties to GObject properties defined in your Python class.
* **Classes:** Combine LibAdwaita classes with your custom ones.

**Example Widget Definition (`src/ui/Bar.blp`):**

```blueprint
using Gtk 4.0;
using Adw 1;
using Astal 4.0;

template $Bar : Astal.Window {
  name: "astal-bar";
  anchor: top | left | right;
  exclusivity: exclusive;

  Box {
    css-classes: ["bar-container", "card"]; // Card is an Adwaita-style utility

    Label {
      css-classes: ["bar-label"];
      // The "template" keyword refers to the Python class instance
      label: bind template.clock_text; 
    }
  }
}

```

### C. Styling Constraints

* **No Hex Codes:** Use named colors or SCSS variables.
* **Scannability:** Prefer many small classes over one giant selector.
* **Dynamic Styling:** If a widget needs to change style based on state (e.g., a "warning" state for battery), use `widget.add_css_class("warning")` in Python rather than changing individual styles.
