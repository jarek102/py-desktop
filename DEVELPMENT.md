# DEVELOPMENT.md

## 1. Tech Stack & Constraints

### Core Technologies

* **Language:** Python 3.14+
* **Desktop Shell Library:** [Astal](https://github.com/Aylur/astal) (via GObject Introspection)
* **UI Toolkit:** GTK 4.0 + LibAdwaita 1.0
* **UI Definition:** Blueprint (`.blp`) files use BLUEPRINT.md to work with .blp files.
* **Styling:** SCSS (`.scss`) -> compiled to CSS
* **Build System:** `Just` (Command Runner).
* **Version Management:** `src/versions.py` handles `gi.require_version` calls. Import it before `gi.repository`.

### ðŸ” Strict Constraints for AI

**You must adhere to these rules when generating code:**

1. **Python style:**
* Use python type hints.


1. **Astal Over GTK:**
* Prefer `astal` namespace widgets over `Gtk` namespace when reactivity is needed.
* For desktop shell windows use `Astal.Window` instead of `Gtk.Window`, use `Gtk.Window` for settings and tool/utility windows.
* Astal windows provide essential desktop shell features (anchors, exclusivity, layers) that standard GTK windows lack.


2. **Blueprint for UI:**
* **NEVER** build widget trees inside Python code (e.g., `box.append(child)`).
* **ALWAYS** define the UI structure in a `.blp` file.
* **ALWAYS** create a matching Python class with the `@Gtk.Template`/`@Blueprint` decorator.


3. **Type Safety & Hallucinations:**
* The project contains a `generated/typings/` folder generated by `astalgen.sh` or `Just`. **Assume these type hints are the absolute truth.**
* Do not invent methods that exist in standard GTK4 if they are missing from the `generated/typings/` definitions.
* *Note:* Astal objects are GObjects. 
* GObject properties can be acessed and set in multiple ways like `label` and `halign`:
* In constructor: label = Gtk.Label(label='Hello World', halign=Gtk.Align.END)
* by set_ methods
* label = Gtk.Label()
* label.set_label('Hello World')
* label.set_halign(Gtk.Align.END)
* using set_property() method
* label = Gtk.Label()
* label.set_property('label', 'Hello World')
* label.set_property('halign', Gtk.Align.END)
* using props
* label = Gtk.Label()
* label.props.label = 'Hello World'
* label.props.halign = Gtk.Align.END
* **Do NOT** Use `label.label = 'Hello World'` or `label.halign = Gtk.Align.END`


4. **Reactive Patterns (The "Binding" Strategy):**
* **In Blueprint:** Use the native bind syntax: `label: bind template.my_prop;`
* **In Python:** Use `GObject.bind_property` for syncing two objects.
* **Do NOT** manually connect to `notify::property` signals for simple value updates.
* **Do NOT** try to use the TypeScript `bind()` syntax in Python code. It does not exist.

5. **Services:**
* Astal services (Battery, Mpris, Network, etc.) are singletons.
* Access them via `get_default()`.
* *Example:* `battery = AstalBattery.get_default()`



---

## 2. Project Structure

We follow a strict separation of **Logic (Python)** and **UI Assets (Blueprints/SCSS)**, organized by **Component**.

```text
src/                     # Contains only Python source code.
â”œâ”€â”€ main.py              # Entry point
â”œâ”€â”€ App.py               # Application logic
â”œâ”€â”€ versions.py          # Handles `gi.require_version` calls. Import it before `gi.repository`. Used to geneate type stubs.
â”œâ”€â”€ ui/                  # Contains the Python logic for widgets, mirroring the structure of `ui/`.
â”‚   â”œâ”€â”€ bar/             # Widgets specific to the top/bottom bar (e.g., Clock, Workspaces, the Bar itself).
â”‚   â”‚   â””â”€â”€ Bar.py       # Python logic for the Bar window.
â”‚   â”œâ”€â”€ quicksettings/   # The control center/menus (e.g., Audio, Bluetooth, Network).
â”‚   â”‚   â”‚                # Can be further grouped by feature (e.g., `ui/quicksettings/audio/`).
â”‚   â”‚   â””â”€â”€ DeviceMenu.py# Python logic for the DeviceMenu window.
â”‚   â””â”€â”€ common/          # Reusable widgets used across the app (e.g., Sliders, Toggles).
â”œâ”€â”€ services/            # Custom services (non-Astal)
â”‚   â””â”€â”€ Compositor.py    # Abstract compositor, compositor specific code should be kept here.
â””â”€â”€ utils/               # Helper functions
ui/
â”œâ”€â”€ bar/
â”‚   â””â”€â”€ Bar.blp          # UI definition for the Bar window.
â”œâ”€â”€ quicksettings/
â”œâ”€â”€ common/
â””â”€â”€ style.scss           # Global styles
generated/
â”œâ”€â”€ typings/             # GObject Introspection stubs (AUTO-GENERATED)
â””â”€â”€ ui/
data/                    # other resources e.g. gschema.xml
```

### Naming Convention
* **Files**: PascalCase for Classes/Widgets (e.g., `VolumeMenu.py`), camelCase or snake_case for utilities.
* **Matching**: `src/ui/bar/Bar.py` should correspond to `ui/bar/Bar.blp`.

---

## 3. Coding Patterns Cheatsheet

### A. Creating a Widget (Python + Blueprint)

**`ui/MyWidget.blp`**

```blueprint
using Gtk 4.0;
using Astal 4.0;

template $MyWidget : Astal.Box {
  css-classes: ["my-widget"];

  Label label_id {
    // Declarative binding to a GObject property defined in Python
    label: bind template.custom_text;
  }
}

```

**`src/ui/MyWidget.py`**

```python
import versions
from gi.repository import Gtk, GObject, Astal
from utils import Blueprint

@Blueprint("MyWidget.blp")
class MyWidget(Astal.Box):
    __gtype_name__ = "MyWidget"

    # Define the GObject property for Blueprint to bind to
    custom_text = GObject.Property(type=str, default="Init")

    def __init__(self):
        super().__init__()
        # Logic here

```

### B. Using Astal Services

```python
from gi.repository import AstalBattery

class BatteryLabel(Astal.Label):
    def __init__(self):
        super().__init__()
        self._battery = AstalBattery.get_default()

        # Bind the battery percentage to this label's label property
        self._battery.bind_property(
            "percentage", 
            self, 
            "label", 
            GObject.BindingFlags.SYNC_CREATE
        )

```

## 4. Styling & UI Architecture

### A. The SCSS Layer

We use a hybrid approach to keep styles manageable:

1. **`style.scss` (Global):**
* **Design Tokens:** Variables for colors, transitions, and spacing.
* **LibAdwaita Integration:** Always prefer referencing `@accent_color`, `@window_bg_color`, etc., to support system-wide dark/light mode.
* **Utilities:** Generic classes like `.mt-10` or `.flex-center`.


2. **Component SCSS:**
* Styles specific to a widget (e.g., `.bar-clock`) are stored near the component or imported into the main sheet.



### B. Blueprint (`.blp`) Patterns

Blueprint is the primary way to define UI.

* **Template Syntax:** Use the `template $ClassName : SuperClass` format.
* **Declarative Bindings:** Use the `bind` keyword to link UI properties to GObject properties defined in your Python class.
* **Classes:** Combine LibAdwaita classes with your custom ones.

**Example Widget Definition (`ui/Bar.blp`):**

```blueprint
using Gtk 4.0;
using Adw 1;
using Astal 4.0;

template $Bar : Astal.Window {
  name: "astal-bar";
  anchor: top | left | right;
  exclusivity: exclusive;

  Box {
    css-classes: ["bar-container", "card"]; // Card is an Adwaita-style utility

    Label {
      css-classes: ["bar-label"];
      // The "template" keyword refers to the Python class instance
      label: bind template.clock_text; 
    }
  }
}

```

**Event Controllers in Blueprint**

To handle events like scrolling or key presses on widgets that don't have direct signals (like `Image`), use `EventController` inside widget.

```blueprint
Image {
  EventControllerScroll {
    flags: vertical;
    scroll => $on_scroll();
  }
}
```

### C. Styling Constraints

* **No Hex Codes:** Use named colors or SCSS variables.
* **Scannability:** Prefer many small classes over one giant selector.
* **Dynamic Styling:** If a widget needs to change style based on state (e.g., a "warning" state for battery), use `widget.add_css_class("warning")` in Python rather than changing individual styles.
