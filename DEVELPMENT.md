# DEVELOPMENT.md

## 1. Tech Stack & Constraints

### Core Technologies

* **Language:** Python 3.14+
* **Desktop Shell Library:** [Astal](https://github.com/Aylur/astal) (via GObject Introspection)
* **UI Toolkit:** GTK 4.0 + LibAdwaita 1.0
* **UI Definition:** Blueprint (`.blp`) files use BLUEPRINT.md to work with .blp files.
* **Styling:** SCSS (`.scss`) -> compiled to CSS
* **Build System:** `Just` (Command Runner).
* **Version Management:** `src/versions.py` handles `gi.require_version` calls. Import it before `gi.repository`.

### ðŸ” Strict Constraints for AI

**You must adhere to these rules when generating code:**

1. **Python style:**
* Use python type hints.
* Don't use very short variable names, execept for iterators.


1. **Astal Over GTK:**
* Prefer `astal` namespace widgets over `Gtk` namespace when reactivity is needed.
* For desktop shell windows use `Astal.Window` instead of `Gtk.Window`, use `Gtk.Window` for settings and tool/utility windows.
* Astal windows provide essential desktop shell features (anchors, exclusivity, layers) that standard GTK windows lack.


2. **Blueprint for UI:**
* **NEVER** build widget trees inside Python code (e.g., `box.append(child)`).
* **ALWAYS** define the UI structure in a `.blp` file.
* **ALWAYS** create a matching Python class with the `@Gtk.Template`/`@Blueprint` decorator.


3. **Type Safety & Hallucinations:**
* The project contains a `generated/typings/` folder generated by `astalgen.sh` or `Just`. **Assume these type hints are the absolute truth.**
* Do not invent methods that exist in standard GTK4 if they are missing from the `generated/typings/` definitions.
* *Note:* Astal objects are GObjects. 
* GObject properties can be acessed and set in multiple ways like `label` and `halign`:
* In constructor: label = Gtk.Label(label='Hello World', halign=Gtk.Align.END)
* by set_ methods
* label = Gtk.Label()
* label.set_label('Hello World')
* label.set_halign(Gtk.Align.END)
* using set_property() method
* label = Gtk.Label()
* label.set_property('label', 'Hello World')
* label.set_property('halign', Gtk.Align.END)
* using props
* label = Gtk.Label()
* label.props.label = 'Hello World'
* label.props.halign = Gtk.Align.END
* **Do NOT** Use `label.label = 'Hello World'` or `label.halign = Gtk.Align.END`


4. **Reactive Patterns (The "Binding" Strategy):**
* **In Blueprint:** Use the native bind syntax: `label: bind template.my_prop;`
* **In Python:** Use `GObject.bind_property` for syncing two objects.
* **Do NOT** manually connect to `notify::property` signals for simple value updates.
* **Do NOT** try to use the TypeScript `bind()` syntax in Python code. It does not exist.

5. **Services:**
* Astal services (Battery, Mpris, Network, etc.) are singletons.
* Access them via `get_default()`.
* *Example:* `battery = AstalBattery.get_default()`



---

## 2. Project Structure

We follow a strict separation of **Logic (Python)** and **UI Assets (Blueprints/SCSS)**, organized by **Component**.

```text
src/                     # Contains only Python source code.
â”œâ”€â”€ main.py              # Entry point
â”œâ”€â”€ App.py               # Application logic
â”œâ”€â”€ versions.py          # Handles `gi.require_version` calls. Import it before `gi.repository`. Used to geneate type stubs.
â”œâ”€â”€ ui/                  # Contains the Python logic for widgets, mirroring the structure of `ui/`.
â”‚   â”œâ”€â”€ bar/             # Widgets specific to the top/bottom bar (e.g., Clock, Workspaces, the Bar itself).
â”‚   â”‚   â””â”€â”€ Bar.py       # Python logic for the Bar window.
â”‚   â”œâ”€â”€ quicksettings/   # The control center/menus (e.g., Audio, Bluetooth, Network).
â”‚   â”‚   â”‚                # Can be further grouped by feature (e.g., `ui/quicksettings/audio/`).
â”‚   â”‚   â””â”€â”€ DeviceMenu.py# Python logic for the DeviceMenu window.
â”‚   â””â”€â”€ common/          # Reusable widgets used across the app (e.g., Sliders, Toggles).
â”œâ”€â”€ services/            # Custom services (non-Astal)
â”‚   â””â”€â”€ Compositor.py    # Abstract compositor, compositor specific code should be kept here.
â”‚   â””â”€â”€ theme_service.py # Desktop light/dark mode persistence and reactive state.
â”‚   â””â”€â”€ power_profile_service.py # Laptop power profile wrapper with visibility gating.
â”‚   â””â”€â”€ system_actions.py # Simple systemctl-backed actions (reboot/poweroff/suspend).
â”‚   â””â”€â”€ scroll_ipc.py    # Scroll compositor IPC adapter (reactive subscribe path).
â””â”€â”€ utils/               # Helper functions
ui/
â”œâ”€â”€ bar/
â”‚   â””â”€â”€ Bar.blp          # UI definition for the Bar window.
â”œâ”€â”€ quicksettings/
â”œâ”€â”€ common/
â””â”€â”€ style.scss           # Global styles
generated/
â”œâ”€â”€ typings/             # GObject Introspection stubs (AUTO-GENERATED)
â””â”€â”€ ui/
data/                    # other resources e.g. gschema.xml
```

### Naming Convention
* **Files**: PascalCase for Classes/Widgets (e.g., `VolumeMenu.py`), camelCase or snake_case for utilities.
* **Matching**: `src/ui/bar/Bar.py` should correspond to `ui/bar/Bar.blp`.

---

## 3. Coding Patterns Cheatsheet

### A. Creating a Widget (Python + Blueprint)

**`ui/MyWidget.blp`**

```blueprint
using Gtk 4.0;
using Astal 4.0;

template $MyWidget : Astal.Box {
  css-classes: ["my-widget"];

  Label label_id {
    // Declarative binding to a GObject property defined in Python
    label: bind template.custom_text;
  }
}

```

**`src/ui/MyWidget.py`**

```python
import versions
from gi.repository import Gtk, GObject, Astal
from utils import Blueprint

@Blueprint("MyWidget.blp")
class MyWidget(Astal.Box):
    __gtype_name__ = "MyWidget"

    # Define the GObject property for Blueprint to bind to
    custom_text = GObject.Property(type=str, default="Init")

    def __init__(self):
        super().__init__()
        # Logic here

```

### B. Using Astal Services

```python
from gi.repository import AstalBattery

class BatteryLabel(Astal.Label):
    def __init__(self):
        super().__init__()
        self._battery = AstalBattery.get_default()

        # Bind the battery percentage to this label's label property
        self._battery.bind_property(
            "percentage", 
            self, 
            "label", 
            GObject.BindingFlags.SYNC_CREATE
        )

```

## 4. Styling & UI Architecture

### A. The SCSS Layer

We use a hybrid approach to keep styles manageable:

1. **`style.scss` (Global):**
* **Design Tokens:** Variables for colors, transitions, and spacing.
* **LibAdwaita Integration:** Always prefer referencing `@accent_color`, `@window_bg_color`, etc., to support system-wide dark/light mode.
* **Utilities:** Generic classes like `.mt-10` or `.flex-center`.


2. **Component SCSS:**
* Styles specific to a widget (e.g., `.bar-clock`) are stored near the component or imported into the main sheet.



### B. Blueprint (`.blp`) Patterns

Blueprint is the primary way to define UI.

* **Template Syntax:** Use the `template $ClassName : SuperClass` format.
* **Declarative Bindings:** Use the `bind` keyword to link UI properties to GObject properties defined in your Python class.
* **Classes:** Combine LibAdwaita classes with your custom ones.

**Example Widget Definition (`ui/Bar.blp`):**

```blueprint
using Gtk 4.0;
using Adw 1;
using Astal 4.0;

template $Bar : Astal.Window {
  name: "astal-bar";
  anchor: top | left | right;
  exclusivity: exclusive;

  Box {
    css-classes: ["bar-container", "card"]; // Card is an Adwaita-style utility

    Label {
      css-classes: ["bar-label"];
      // The "template" keyword refers to the Python class instance
      label: bind template.clock_text; 
    }
  }
}

```

**Event Controllers in Blueprint**

To handle events like scrolling or key presses on widgets that don't have direct signals (like `Image`), use `EventController` inside widget.

```blueprint
Image {
  EventControllerScroll {
    flags: vertical;
    scroll => $on_scroll();
  }
}
```

### C. Styling Constraints

* **No Hex Codes:** Use named colors or SCSS variables.
* **Scannability:** Prefer many small classes over one giant selector.
* **Dynamic Styling:** If a widget needs to change style based on state (e.g., a "warning" state for battery), use `widget.add_css_class("warning")` in Python rather than changing individual styles.

---

## 5. Testing & Verification (Current)

### Automated

* Tests live in `tests/` (separate tree):
* Unit tests: `tests/unit/`
* Manual checklist: `tests/manual/CHECKLIST.md`
* Commands:
* `just test` -> run pytest
* `just check` -> compile + tests
* `just verify-stubs` -> sanity-check generated Gtk stubs

### Runtime Smoke

* Nested compositor scripts:
* `scripts/run-niri-nested.sh`
* `scripts/run-scroll-nested.sh`
* `scripts/run-hyprland-test.sh`
* IPC smoke:
* `scripts/smoke-app-ipc.sh`
* `just smoke-ipc`

### Astal IPC for Testing

* App request handling supports:
* `ping` -> `pong`
* `status` -> JSON state snapshot
* `toggle-device-menu` -> toggles quick settings and returns visibility state
* `close-popups` -> closes active popup
* Helper:
* `scripts/astal-ipc.sh <instance-name> <request>`

### Compositor Strategy (Current)

* **Niri:** Native AstalNiri path.
* **Hyprland:** Native AstalHyprland path (still needs runtime testing coverage).
* **Scroll:** Python IPC backend via `scrollmsg` with reactive `subscribe` monitoring.
* Scroll nested smoke helper exports `SCROLLSOCK`/`SWAYSOCK`/`I3SOCK` and uses `GSK_RENDERER=gl` by default for better stability on NVIDIA.

### DeviceMenu Strategy (Current)

* Theme mode is managed via `ThemeService` (`org.gnome.desktop.interface` `color-scheme`).
* Power profile state is managed via `PowerProfileService`.
* Power profile controls are visible only when battery is present.
* Speaker/microphone collapsed sliders show active device labels below slider rows.
* For AstalPowerProfiles profile list reads, prefer `props.profiles` (safe in this environment) over direct getter calls that may crash.

### Nested Niri Strategy (Current)

* Nested runs default to `config/niri-nested.kdl` unless overridden by `PY_DESKTOP_NIRI_CONFIG`.
* Smoke checks capture and validate nested `WAYLAND_DISPLAY` and `NIRI_SOCKET`.
* Nested socket must differ from host socket when host `NIRI_SOCKET` is set.

### Nested Scroll Strategy (Current)

* Nested runs default to `config/scroll-nested.conf` unless overridden by `PY_DESKTOP_SCROLL_CONFIG`.
* Scroll startup uses `-V` and derives nested `WAYLAND_DISPLAY` from log line:
  * `Running compositor on wayland display '<name>'`
* Nested IPC socket path is deterministic:
  * `/run/user/$UID/scroll-ipc.$UID.$SCROLL_PID.sock`
* Per `man scroll`: do not mix options and positional command in one invocation.
* App startup environment should include:
  * `WAYLAND_DISPLAY`, `SCROLLSOCK`, `SWAYSOCK`, `I3SOCK`, `XDG_CURRENT_DESKTOP=scroll`, `XDG_SESSION_TYPE=wayland`

### Safety During Manual Tests

* Avoid loud sound tests.
* Avoid high-intensity brightness flashing.
* Prefer state/assertion checks over disruptive stress tests.

---

## 6. Planning Guidance

Use `DEVELPMENT.md` as the primary long-lived engineering document.

When larger feature batches start, add a dedicated section:
* **Roadmap / Milestones**
* **Current Sprint / Next Tasks**
* **Known Risks / Gaps**

Create a separate plan file only when:
* the plan is temporary/experimental, or
* multiple alternative implementation tracks need parallel docs.
