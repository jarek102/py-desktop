# DEVELOPMENT.md

## 1. Tech Stack & Constraints

### Core Technologies

* **Language:** Python 3.14+
* **Desktop Shell Library:** [Astal](https://github.com/Aylur/astal) (via GObject Introspection)
* **UI Toolkit:** GTK 4.0 + LibAdwaita 1.0
* **UI Definition:** Blueprint (`.blp`) files use BLUEPRINT.md to work with .blp files.
* **Styling:** SCSS (`.scss`) -> compiled to CSS
* **Build System:** `Just` (Command Runner).
* **Version Management:** `src/versions.py` handles `gi.require_version` calls. Import it before `gi.repository`.

### üîç Strict Constraints for AI

**You must adhere to these rules when generating code:**

1. **Astal Over GTK:**
* Prefer `astal` namespace widgets over `Gtk` namespace when reactivity is needed.
* For desktop shell windows use `Astal.Window` instead of `Gtk.Window`, use `Gtk.Window` for settings and tool/utility windows.
* Astal windows provide essential desktop shell features (anchors, exclusivity, layers) that standard GTK windows lack.


2. **Blueprint for UI:**
* **NEVER** build widget trees inside Python code (e.g., `box.append(child)`).
* **ALWAYS** define the UI structure in a `.blp` file.
* **ALWAYS** create a matching Python class with the `@Gtk.Template` decorator.


3. **Type Safety & Hallucinations:**
* The project contains a `typings/` folder generated by `astalgen.sh`. **Assume these type hints are the absolute truth.**
* Do not invent methods that exist in standard GTK4 if they are missing from the `typings/` definitions.
* *Note:* Astal objects are GObjects. They use `get_property("name")` and `set_property("name", val)` under the hood, but Python properties (e.g., `widget.visible = True`) are preferred.


4. **Reactive Patterns (The "Binding" Strategy):**
* **In Blueprint:** Use the native bind syntax: `label: bind template.my_prop;`
* **In Python:** Use `GObject.bind_property` for syncing two objects.
* **Do NOT** manually connect to `notify::property` signals for simple value updates.
* **Do NOT** try to use the TypeScript `bind()` syntax in Python code. It does not exist.

5. **Services:**
* Astal services (Battery, Mpris, Network, etc.) are singletons.
* Access them via `get_default()`.
* *Example:* `battery = AstalBattery.get_default()`



---

## 2. Project Structure

We follow a strict separation of **Logic (Python)** and **UI Assets (Blueprints/SCSS)**, organized by **Component**.

```text
src/                     # Contains only Python source code.
‚îú‚îÄ‚îÄ main.py              # Entry point
‚îú‚îÄ‚îÄ App.py               # Application logic
‚îú‚îÄ‚îÄ ui/                  # Contains the Python logic for widgets, mirroring the structure of `ui/`.
‚îÇ   ‚îú‚îÄ‚îÄ bar/             # Widgets specific to the top/bottom bar (e.g., Clock, Workspaces, the Bar itself).
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Bar.py       # Python logic
‚îÇ   ‚îú‚îÄ‚îÄ quicksettings/   # The control center/menus (e.g., Audio, Bluetooth, Network).
‚îÇ   ‚îÇ   ‚îÇ                # Can be further grouped by feature (e.g., `ui/quicksettings/audio/`).
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DeviceMenu.py
‚îÇ   ‚îî‚îÄ‚îÄ common/          # Reusable widgets used across the app (e.g., Sliders, Toggles).
‚îú‚îÄ‚îÄ services/            # Custom services (non-Astal)
‚îî‚îÄ‚îÄ utils/               # Helper functions
ui/
‚îú‚îÄ‚îÄ bar/
‚îÇ   ‚îî‚îÄ‚îÄ Bar.blp          # UI definition
‚îú‚îÄ‚îÄ quicksettings/
‚îú‚îÄ‚îÄ common/
‚îî‚îÄ‚îÄ style.scss           # Global styles
generated/
‚îú‚îÄ‚îÄ typings/             # GObject Introspection stubs (AUTO-GENERATED)
‚îî‚îÄ‚îÄ ui/
data/                    # other resources e.g. gschema.xml
```

### Naming Convention
* **Files**: PascalCase for Classes/Widgets (e.g., `VolumeMenu.py`), camelCase or snake_case for utilities.
* **Matching**: `src/ui/bar/Bar.py` should correspond to `ui/bar/Bar.blp`.

---

## 3. Coding Patterns Cheatsheet

### A. Creating a Widget (Python + Blueprint)

**`ui/MyWidget.blp`**

```blueprint
using Gtk 4.0;
using Astal 4.0;

template $MyWidget : Astal.Box {
  css-classes: ["my-widget"];

  Label label_id {
    // Declarative binding to a GObject property defined in Python
    label: bind template.custom_text;
  }
}

```

**`src/ui/MyWidget.py`**

```python
import versions
from gi.repository import Gtk, GObject, Astal
from utils import Blueprint

@Blueprint("MyWidget.blp")
class MyWidget(Astal.Box):
    __gtype_name__ = "MyWidget"

    # Define the GObject property for Blueprint to bind to
    custom_text = GObject.Property(type=str, default="Init")

    def __init__(self):
        super().__init__()
        # Logic here

```

### B. Using Astal Services

```python
from gi.repository import AstalBattery

class BatteryLabel(Astal.Label):
    def __init__(self):
        super().__init__()
        self._battery = AstalBattery.get_default()

        # Bind the battery percentage to this label's label property
        self._battery.bind_property(
            "percentage", 
            self, 
            "label", 
            GObject.BindingFlags.SYNC_CREATE
        )

```

## 4. Styling & UI Architecture

### A. The SCSS Layer

We use a hybrid approach to keep styles manageable:

1. **`style.scss` (Global):**
* **Design Tokens:** Variables for colors, transitions, and spacing.
* **LibAdwaita Integration:** Always prefer referencing `@accent_color`, `@window_bg_color`, etc., to support system-wide dark/light mode.
* **Utilities:** Generic classes like `.mt-10` or `.flex-center`.


2. **Component SCSS:**
* Styles specific to a widget (e.g., `.bar-clock`) are stored near the component or imported into the main sheet.



### B. Blueprint (`.blp`) Patterns

Blueprint is the primary way to define UI.

* **Template Syntax:** Use the `template $ClassName : SuperClass` format.
* **Declarative Bindings:** Use the `bind` keyword to link UI properties to GObject properties defined in your Python class.
* **Classes:** Combine LibAdwaita classes with your custom ones.

**Example Widget Definition (`ui/Bar.blp`):**

```blueprint
using Gtk 4.0;
using Adw 1;
using Astal 4.0;

template $Bar : Astal.Window {
  name: "astal-bar";
  anchor: top | left | right;
  exclusivity: exclusive;

  Box {
    css-classes: ["bar-container", "card"]; // Card is an Adwaita-style utility

    Label {
      css-classes: ["bar-label"];
      // The "template" keyword refers to the Python class instance
      label: bind template.clock_text; 
    }
  }
}

```

### C. Styling Constraints

* **No Hex Codes:** Use named colors or SCSS variables.
* **Scannability:** Prefer many small classes over one giant selector.
* **Dynamic Styling:** If a widget needs to change style based on state (e.g., a "warning" state for battery), use `widget.add_css_class("warning")` in Python rather than changing individual styles.
